// index.js — mercari-scraper（恒久対策入り 完全版）
// Node.js 18 + Express + Playwright (chromium)
// 環境変数：PORT(10000)/API_KEY/HEADLESS(true)/DIRECT_FIRST(true)/DIRECT_ONLY('1'で有効)
//            FETCH_TIMEOUT_MS(7000)/NAV_TIMEOUT_MS(25000)

const express = require('express');
const { chromium } = require('playwright');

const app = express();
app.use(express.json({ limit: '1mb' }));

// ====== 環境変数 ======
const PORT = Number(process.env.PORT || 10000);
const API_KEY = process.env.API_KEY || ''; // 必須（/scrape 系）
const HEADLESS = String(process.env.HEADLESS ?? 'true').toLowerCase() !== 'false';
const DIRECT_FIRST = String(process.env.DIRECT_FIRST ?? 'true').toLowerCase() !== 'false';
const DIRECT_ONLY = process.env.DIRECT_ONLY === '1';
const FETCH_TIMEOUT_MS = Number(process.env.FETCH_TIMEOUT_MS || 7000);
const NAV_TIMEOUT_MS = Number(process.env.NAV_TIMEOUT_MS || 25000);

// ====== 共通ヘルパ ======
const ts = () => new Date().toISOString();
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

function sanitize(str) {
  if (str == null) return null;
  return String(str).replace(/\s+/g, ' ').trim() || null;
}
function formatJPY(n) {
  if (typeof n !== 'number' || !Number.isFinite(n)) return null;
  return `¥ ${n.toLocaleString('ja-JP')}`;
}
function toNumberLike(v) {
  if (v == null) return null;
  const n = Number(String(v).replace(/[^\d.]/g, ''));
  return Number.isFinite(n) ? Math.round(n) : null;
}
function isIncomplete(data) {
  if (!data) return true;
  const hasTitle = !!sanitize(data.title);
  const hasPrice = Number.isFinite(data.priceNumber);
  const hasDesc = !!sanitize(data.description);
  return !(hasTitle || hasPrice || hasDesc);
}
function isSuspiciousPrice(n) {
  // 過去事例：LP中の「¥300」など別価格のノイズ
  // 極端に小さい価格は怪しい（必要なら閾値調整）
  return Number.isFinite(n) && n > 0 && n < 500;
}

// ====== HTTP 直取り（Mercari/Maker） ======
async function fetchText(url, { timeout = FETCH_TIMEOUT_MS } = {}) {
  const ctrl = new AbortController();
  const id = setTimeout(() => ctrl.abort('timeout'), timeout);
  try {
    const res = await fetch(url, {
      headers: {
        'User-Agent':
          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
        'Accept-Language': 'ja-JP,ja;q=0.9,en-US;q=0.8,en;q=0.7',
        'Cache-Control': 'no-cache',
      },
      signal: ctrl.signal,
    });
    const text = await res.text();
    return text;
  } finally {
    clearTimeout(id);
  }
}

function extractJsonLdProductBlocks(html) {
  const blocks = [];
  const re = /<script[^>]+type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi;
  let m;
  while ((m = re.exec(html))) {
    const raw = (m[1] || '').trim();
    if (!raw) continue;
    try {
      const json = JSON.parse(raw);
      if (Array.isArray(json)) {
        for (const obj of json) {
          if (!obj) continue;
          const t = String(obj['@type'] || '').toLowerCase();
          if (t.includes('product')) blocks.push(obj);
        }
      } else if (json && String(json['@type'] || '').toLowerCase().includes('product')) {
        blocks.push(json);
      }
    } catch {
      // JSON崩れは無視
    }
  }
  return blocks;
}

function findMetaContent(html, property) {
  const re = new RegExp(
    `<meta[^>]+property=["']${property.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')}["'][^>]*content=["']([^"']+)["'][^>]*>`,
    'i'
  );
  const m = re.exec(html);
  return m ? m[1] : null;
}
function findItempropPrice(html) {
  const re = /itemprop=["']price["'][^>]*content=["']([^"']+)["']/i;
  const m = re.exec(html);
  return m ? m[1] : null;
}
function scanYenPattern(html) {
  const re = /¥\s?([\d,]{2,})/g;
  let best = null;
  let m;
  while ((m = re.exec(html))) {
    const n = toNumberLike(m[1]);
    if (!best || (n && n > best)) best = n;
  }
  return best;
}

function mapProduct(obj = {}) {
  const title = sanitize(obj.name);
  const brand = sanitize(obj?.brand?.name || obj?.brand);
  let priceNumber = null;
  let currency = null;
  const offers = obj?.offers;
  if (offers) {
    const pick = Array.isArray(offers) ? offers[0] : offers;
    priceNumber = toNumberLike(pick?.price);
    currency = pick?.priceCurrency || null;
  }
  return { title, brand, priceNumber, currency };
}

async function directFetchMercari(url) {
  const html = await fetchText(url);
  const products = extractJsonLdProductBlocks(html);
  let data = {};
  for (const p of products) {
    const d = mapProduct(p);
    if (d.title || d.priceNumber) {
      data = d;
      break;
    }
  }
  if (!data.priceNumber) {
    // meta や itemprop
    const ogAmt = findMetaContent(html, 'product:price:amount') || findMetaContent(html, 'og:price:amount');
    const itemprop = findItempropPrice(html);
    data.priceNumber = toNumberLike(ogAmt) ?? toNumberLike(itemprop) ?? scanYenPattern(html) ?? null;
  }
  const price = Number.isFinite(data.priceNumber) ? formatJPY(data.priceNumber) : null;
  // タイトルのフォールバック
  if (!data.title) {
    data.title = sanitize(findMetaContent(html, 'og:title')) || null;
  }
  // 説明は直取りだと不安定なので省略（Playwrightで拾う）
  const description = null;
  return { title: data.title || null, brand: data.brand || null, price, priceNumber: data.priceNumber ?? null, currency: data.currency || 'JPY', description };
}

async function directFetchMaker(url) {
  const html = await fetchText(url);
  const products = extractJsonLdProductBlocks(html);
  let data = {};
  for (const p of products) {
    const d = mapProduct(p);
    if (d.title) {
      data = d;
      break;
    }
  }
  if (!data.title) data.title = sanitize(findMetaContent(html, 'og:title')) || null;
  const descMeta = (() => {
    const re = /<meta[^>]+name=["']description["'][^>]*content=["']([^"']+)["'][^>]*>/i;
    const m = re.exec(html);
    return m ? m[1] : null;
  })();
  return {
    title: data.title || null,
    brand: data.brand || null,
    price: Number.isFinite(data.priceNumber) ? formatJPY(data.priceNumber) : null,
    priceNumber: data.priceNumber ?? null,
    currency: data.currency || 'JPY',
    description: descMeta ? sanitize(descMeta) : null,
    htmlLen: html.length,
  };
}

// ====== Playwright（高信頼・恒久対策入り） ======
let sharedBrowser = null;

async function getBrowser() {
  if (sharedBrowser && sharedBrowser.isConnected()) return sharedBrowser;
  sharedBrowser = await chromium.launch({ headless: HEADLESS });
  // 万一のクラッシュ復旧
  sharedBrowser.on('disconnected', () => {
    sharedBrowser = null;
  });
  return sharedBrowser;
}

async function scrapeWithPlaywright(url, type = 'mercari') {
  const browser = await getBrowser();
  const context = await browser.newContext({
    userAgent:
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
    locale: 'ja-JP',
    timezoneId: 'Asia/Tokyo',
    viewport: { width: 1366, height: 900 },
  });

  // 画像だけブロック（CSS/JSは通す）
  await context.route('**/*', (route) => {
    const t = route.request().resourceType();
    if (t === 'image') return route.abort();
    return route.continue();
  });

  const page = await context.newPage();
  page.setDefaultNavigationTimeout(NAV_TIMEOUT_MS);
  await page.setExtraHTTPHeaders({
    'Accept-Language': 'ja-JP,ja;q=0.9,en-US;q=0.8,en;q=0.7',
    'Cache-Control': 'no-cache',
  });

  try {
    await page.goto(url, { waitUntil: 'domcontentloaded', timeout: NAV_TIMEOUT_MS });
    // SPA/ハイドレーションの猶予
    await page.waitForTimeout(1200);
    // 代表要素の出現待ち（失敗しても続行）
    await page.waitForSelector('[data-testid="item-description"], h1, article', { timeout: 8000 }).catch(() => {});

    // ld+json（Product）を優先
    const product = await (async () => {
      const handles = await page.locator('script[type="application/ld+json"]').all();
      for (const h of handles) {
        const txt = (await h.textContent())?.trim();
        if (!txt) continue;
        try {
          const json = JSON.parse(txt);
          const arr = Array.isArray(json) ? json : [json];
          for (const obj of arr) {
            if (!obj) continue;
            const t = String(obj['@type'] || '').toLowerCase();
            if (t.includes('product')) return obj;
          }
        } catch {}
      }
      return null;
    })();

    let title =
      sanitize(product?.name) ||
      sanitize(await page.locator('meta[property="og:title"]').getAttribute('content')) ||
      sanitize(await page.title());

    let brand = sanitize(product?.brand?.name || product?.brand) || null;

    // 価格（数値優先）
    let priceNumber = null;
    if (product?.offers) {
      const offers = Array.isArray(product.offers) ? product.offers[0] : product.offers;
      priceNumber = toNumberLike(offers?.price);
    }
    if (!priceNumber) {
      const ogAmt = await page.locator('meta[property="product:price:amount"], meta[property="og:price:amount"]').getAttribute('content');
      priceNumber = toNumberLike(ogAmt);
    }
    let price = Number.isFinite(priceNumber) ? formatJPY(priceNumber) : null;
    const currency = (product?.offers && (Array.isArray(product.offers) ? product.offers[0]?.priceCurrency : product.offers.priceCurrency)) || 'JPY';

    // 説明（候補を収集→連結、改行維持）
    const description = await page.evaluate(() => {
      const chunks = [];
      const byTestId = document.querySelector('[data-testid="item-description"]');
      if (byTestId) chunks.push(byTestId.innerText || byTestId.textContent || '');
      // article / main 内テキストも拾う（長文のみ）
      document.querySelectorAll('article, main, section').forEach((el) => {
        const t = el.innerText || el.textContent || '';
        if (t && t.length > 80) chunks.push(t);
      });
      const joined = chunks.join('\n').replace(/\n{3,}/g, '\n\n').trim();
      return joined || null;
    });

    const data = { title, brand, price, priceNumber, currency, description };

    // 品質ゲート（全部欠け or 価格が怪しい）
    if (isIncomplete(data) || isSuspiciousPrice(priceNumber)) {
      return { ok: false, via: 'playwright', error: 'playwright_incomplete', data };
    }

    return { ok: true, via: 'playwright', data };
  } finally {
    // コンテキストは都度閉じる（ブラウザは共有して高速化）
    await context.close().catch(() => {});
  }
}

// ====== 認証ミドルウェア ======
function requireApiKey(req, res, next) {
  if (!API_KEY) {
    return res.status(500).json({ ok: false, error: 'Server not configured: API_KEY missing' });
  }
  const key = req.header('x-api-key') || '';
  if (key !== API_KEY) {
    return res.status(401).json({ ok: false, error: 'Unauthorized' });
  }
  next();
}

// ====== ルータ ======

// 匿名OK
app.get('/', (req, res) => {
  res.json({ ok: true, service: 'mercari-scraper', ts: ts() });
});

// 匿名OK
app.get('/health', (req, res) => {
  res.json({ ok: true, ts: ts() });
});

// 匿名OK（ブラウザウォームアップ）
app.get('/warmup', async (req, res) => {
  try {
    await getBrowser();
    res.json({ ok: true, warmed: true, ts: ts() });
  } catch (e) {
    res.status(500).json({ ok: false, error: String(e && e.message ? e.message : e) });
  }
});

// 誤用防止：GET /scrape は405
app.get('/scrape', (req, res) => {
  res.status(405).json({ ok: false, error: 'Method Not Allowed. Use POST /scrape' });
});

// 本命
app.post('/scrape', requireApiKey, async (req, res) => {
  try {
    const { url, type = 'mercari', quick = true, directOnly = false } = req.body || {};
    if (!url) return res.status(400).json({ ok: false, error: 'url is required' });

    const wantDirectOnly = DIRECT_ONLY || !!directOnly;
    const useDirectFirst = DIRECT_FIRST && !!quick;

    // maker/mercari で分岐
    const doDirect = async () => {
      if (type === 'maker') return await directFetchMaker(url);
      return await directFetchMercari(url);
    };

    // 直取りだけのモード
    if (wantDirectOnly) {
      const data = await doDirect();
      return res.json({ ok: true, url, type, via: 'direct', data });
    }

    // Playwright直行（quick:falseなど）
    if (!useDirectFirst) {
      const r = await scrapeWithPlaywright(url, type);
      if (!r.ok) {
        // 取り切れなかった（品質ゲートNG）
        return res.status(200).json({ ok: false, url, type, via: 'playwright', error: 'playwright_incomplete', data: r.data });
      }
      return res.json({ ok: true, url, type, via: 'playwright', data: r.data });
    }

    // 直取り→品質NGならフォールバック
    const direct = await doDirect();
    const qualityBad = isIncomplete(direct) || isSuspiciousPrice(direct.priceNumber);
    if (!qualityBad) {
      return res.json({ ok: true, url, type, via: 'direct', data: direct });
    }

    // Playwright フォールバック
    const r = await scrapeWithPlaywright(url, type);
    if (!r.ok) {
      return res.status(200).json({ ok: false, url, type, via: 'playwright', error: 'playwright_incomplete', data: r.data });
    }
    return res.json({ ok: true, url, type, via: 'playwright', data: r.data });
  } catch (e) {
    const msg = String(e && e.message ? e.message : e);
    // 特徴的なクラッシュはメッセージごと返す（再起動促し）
    return res.status(500).json({ ok: false, error: msg });
  }
});

// mercari + maker を同時スクレイプ（必要に応じて）
app.post('/scrapeBoth', requireApiKey, async (req, res) => {
  try {
    const { mercariUrl, makerUrl } = req.body || {};
    if (!mercariUrl && !makerUrl) return res.status(400).json({ ok: false, error: 'mercariUrl or makerUrl is required' });

    const out = { mercari: null, maker: null };

    if (mercariUrl) {
      // まず直取り→不足なら Playwright
      const d = await directFetchMercari(mercariUrl);
      if (isIncomplete(d) || isSuspiciousPrice(d.priceNumber)) {
        const r = await scrapeWithPlaywright(mercariUrl, 'mercari');
        out.mercari = r.ok ? r.data : (r.data || d);
      } else {
        out.mercari = d;
      }
    }
    if (makerUrl) {
      const d2 = await directFetchMaker(makerUrl);
      // maker は基本直取りでOK（必要なら将来Playwright拡張）
      out.maker = d2;
    }

    // merged生成（サンプル方針）
    const merged = (() => {
      const m = out.mercari || {};
      const k = out.maker || {};
      const brand = sanitize(m.brand || k.brand);
      // ざっくり商品名（公式 or mercari から）
      const productName = sanitize((k.title || '').replace(/\s+/g, ' ')) || sanitize(m.title);
      const priceNumber = Number.isFinite(m.priceNumber) ? m.priceNumber : (Number.isFinite(k.priceNumber) ? k.priceNumber : null);
      const price = Number.isFinite(priceNumber) ? formatJPY(priceNumber) : null;
      const currency = m.currency || k.currency || 'JPY';
      const condition = sanitize(m.condition || null) || null;
      const description_user = sanitize(m.description || null) || null;
      const specs_official = Array.isArray(k.specs_official) ? k.specs_official : [];
      const features_official = Array.isArray(k.features_official) ? k.features_official : [];
      return { brand, productName, price, priceNumber, currency, condition, description_user, specs_official, features_official };
    })();

    return res.json({ ok: true, data: { mercari: out.mercari, maker: out.maker, merged } });
  } catch (e) {
    return res.status(500).json({ ok: false, error: String(e && e.message ? e.message : e) });
  }
});

// （任意）HTML長の探針
app.post('/probe', requireApiKey, async (req, res) => {
  try {
    const { url } = req.body || {};
    if (!url) return res.status(400).json({ ok: false, error: 'url is required' });
    const html = await fetchText(url);
    return res.json({ ok: true, htmlLen: html.length });
  } catch (e) {
    return res.status(500).json({ ok: false, error: String(e && e.message ? e.message : e) });
  }
});

// ====== サーバ起動 ======
app.listen(PORT, () => {
  console.log(`[mercari-scraper] listening on :${PORT} HEADLESS=${HEADLESS} DIRECT_FIRST=${DIRECT_FIRST}`);
});

// SIGTERM/SIGINTでブラウザを安全に閉じる
const shutdown = async () => {
  try {
    if (sharedBrowser) await sharedBrowser.close();
  } catch {}
  process.exit(0);
};
process.on('SIGTERM', shutdown);
process.on('SIGINT', shutdown);
